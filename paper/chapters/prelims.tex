\chapter{Preliminares}\label{chap:prelims}


\section{Algoritmos libres de locks}\label{sec:lockfree}
En el contexto de la programación concurrente, los algoritmos libres de locks, también llamados algoritmos optimistas, son algoritmos que actuan sobre un recurso compartido por distintos hilos de ejecución y utilizan una operación atómica como \emph{compare and set} (CAS) para modificar el recurso.
En el caso que la llamada a CAS falle, el algoritmo vuelve a ejecutarse hasta que el recurso sea modificado con exito.
Esta clase de algoritmos permiten que los distintos hilos de ejecución no deban frenar su ejecución para esperar que un recurso se libere, como es el caso en algoritmos que utilizan algún tipo de lock sobre un recurso.
De esta manera uno puede obtener mejores tiempos de ejecución ya que los tiempos de espera son eliminados.
A continuación se presenta un ejemplo de un contador y una operación \mintinline{haskell}{inc} para incrementar el valor del contador de manera segura.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data Counter = Ref Int

inc :: Counter -> IO ()
inc counter = do
    loop <- newRef True
    whileM_ (readRef loop) $ do
        oldValue <- readRef counter
        let newValue = oldValue + 1
        success <- atomCAS counter oldValue newValue
        if success
            then writeRef loop False
            else return ()
\end{minted}
\caption{Algoritmo optimista para incrementar un contador}
\label{fig:lockfree-counter-example}
\end{figure}

En el código de la Fig. \ref{fig:lockfree-counter-example} se presenta la estructura del contador: una referencia a un entero.
La operación \mintinline{haskell}{inc} se encarga de incrementar el valor de esta referencia de manera segura en el caso de que el contador sea compartido con otros hilos de ejecución.
En el algoritmo para esta operación, primero se declara una referencia booleana \mintinline{haskell}{loop} para luego poder mantener un ciclo con la función de Haskell \mintinline{haskell}{whileM_}.
En el ciclo se realiza una lectura del valor del contador, guardando el resultado en la variable \mintinline{haskell}{oldValue}, para luego realizar la llamada a la función \mintinline{haskell}{atomCAS}.

Esta llamada realizará una nueva lectura del valor del contador.
Si el valor leído coincide con el de \mintinline{haskell}{oldValue} se modifica el valor del contador con el valor de \mintinline{haskell}{newValue}, retornando \mintinline{haskell}{True} como resultado de la función.
Si los valores no coinciden significa que hubo un hilo de ejecución que logró modificar el valor del contador luego de que lo leamos inicialmente en la línea.
En este caso no se realizan cambios y la llamada a \mintinline{haskell}{atomCAS} retornará \mintinline{haskell}{False}.
Es importante notar que todas las acciones de la función \mintinline{haskell}{atomCAS} son realizadas de manera atómica.

Según el valor de retorno, el algoritmo de la función \mintinline{haskell}{inc} terminará la ejecución modificando el valor de la referencia \mintinline{haskell}{loop} a \mintinline{haskell}{False} para detener el ciclo en el caso de éxito o volverá a iniciar el ciclo.
La línea 12 de la Fig. \ref{fig:lockfree-counter-example} que llama a la función \mintinline{haskell}{return} con parámetro \mintinline{haskell}{()} no realiza ninguna operación y simplemente permite volver a iniciar el ciclo.

En este trabajo vamos a utilizar este esquema de algoritmos para varias de las implementaciones. Tendremos también variantes para la implementación de algoritmos de este estilo ya que es posible definir estos algoritmos utilizando distintas primitivas de sincronización para sobre las cuales se pueden implementar distintas versiones de la función \mintinline{haskell}{atomCAS}.
Estas versiones se detallan a continuación en la sección \ref{sec:primitives}.

\section{Primitivas de sincronización} \label{sec:primitives}
El lenguaje de programación Haskell ofrece, mediante su compilador GHC, distintas primitivas de sincronización para poder manejar recursos compartidos entre distintos hilos de ejecución.
En este trabajo se utilizan los tipos de datos \mintinline{haskell}{IORef} y \mintinline{haskell}{TVar} de la librería \mintinline{haskell}{STM} para las implementaciones que se detallan en el próximo capítulo.
Estos tipos de datos son distintas maneras de referenciar objetos mutables, similares a punteros en otros lenguajes de programación, y proveen funciones para poder ser modificadas de manera atómica para poder ser utilizadas en programación concurrente.

\subsection{IORef}\label{sub:ioref}
El tipo de datos \mintinline{haskell}{IORef} es comunmente utilizado en programas Haskell como la manera de referenciar objetos mutables.
A continuación se detallan las funciones para crear, leer, escribir y modificar atómicamente los valores contenidos en una referencia \mintinline{haskell}{IORef}.

\begin{figure}[H]
\centering
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
newIORef   :: a -> IO (IORef a)
readIORef  :: IORef a -> IO a
writeIORef :: IORef a -> a -> IO a
atomicModifyIORef :: IORef a -> (a -> (a,b)) -> IO b
\end{minted}
\caption{Funciones para \mintinline{haskell}{IORef}}
\label{fig:ioref-interface}
\end{figure}

La función \mintinline{haskell}{atomicModifyIORef} de la última línea de la Fig. \ref{fig:ioref-interface} es la única función que realiza una modificación sobre una referencia del tipo \mintinline{haskell}{IORef} atómicamente.
La función recibe como parámetros una referencia a modificar y una función para modificar el valor contenido en la referencia y retornar un valor en función del valor previo en la referencia como resultado de la función. El código que presenta en la Fig. \ref{fig:atomicModifyIORef-behavior} muestra un comportamiento equivalente al de \mintinline{haskell}{atomicModifyIORef}. Este código se encuentra presentado en el trabajo de \cite{linked-list}.

\begin{figure}[tb]
\centering
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
atomicModifyIORef r f = do
   a <- readIORef r
   let p = f a
   writeIORef r (fst p)
   return (snd p)
\end{minted}
\caption{Comportamiento de la función \mintinline{haskell}{atomicModifyIORef}}
\label{fig:atomicModifyIORef-behavior}
\end{figure}

La función \mintinline{haskell}{atomicModifyIORef} es crucial para implementar una versión de \mintinline{haskell}{atomCAS} ya que es la única función que permite manipular referencias de tipo \mintinline{haskell}{IORef} de manera atómica.
Generalmente, una función de CAS como \mintinline{haskell}{atomCAS} debe recibir tres parámetros: la referencia a modificar, el valor previamente leído que compararemos atómicamente con el valor actual de la referencia, y el valor nuevo a guardar en la referencia.
Luego, el resultado de la función debe ser un booleano que indicará si la comparación entre el valor leído y el valor actual de la referencia es exitosa.

En este caso, para aplicar \mintinline{haskell}{atomCAS} sobre una referencia de tipo IORef, utilizaremos la función de \mintinline{haskell}{atomicModifyIORef} pasándole como segundo parámetro una función que compare el valor leído con el actual y retorne una tupla
con el valor a guardar en la referencia y el booleano resultante de la comparación.
Si la operación es exitosa, se guarda el valor nuevo en la referencia.
En caso contrario, se vuelve a guardar el valor actual.
Este comportamiento se refleja en el código de la Fig. \ref{fig:atomcasio}, también presentado en \cite{linked-list}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
atomCASIO :: Eq a => IORef a -> a -> a -> IO Bool
atomCASIO ptr old new =
  atomicModifyIORef ptr (\ cur -> if cur == old
                                  then (new, True)
                                  else (cur, False))
\end{minted}
\caption{\mintinline{haskell}{atomCAS} utilizando IORef}
\label{fig:atomcasio}
\end{figure}

Implementada esta función, el código para el ejemplo del contador queda de la siguiente manera, utilizando \mintinline{haskell}{IORef} como referencia y las funciones \mintinline{haskell}{readIORef}, \mintinline{haskell}{writeIORef}, y \mintinline{haskell}{atomCASIO}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data Counter = IORef Int

inc :: Counter -> IO ()
inc counter = do
    loop <- newIORef True
    whileM_ (readIORef loop) $ do
        oldValue <- readIORef counter
        let newValue = oldValue + 1
        success <- atomCASIO counter oldValue newValue
        if success
            then writeIORef loop False
            else return ()
\end{minted}
\caption{Algoritmo optimista para incrementar un contador utilizando \mintinline{haskell}{IORef}}
\label{fig:lockfree-counter-example-ioref}
\end{figure}

\subsection{STM}\label{sub:stm}
La librería STM de Haskell tiene el objetivo de ofrecer al programador la posibilidad de componer distintas funciones y que luego estas sean ejecutadas de manera atómica.
Para lograr esto, la librería provee el tipo de mónada STM para distinguir las funciones que se realizan dentro de esta mónada con la mónada IO y el tipo de referencia \mintinline{haskell}{TVar}.
Es decir, las funciones de la mónada STM sólo pueden componerse con funciones de la misma mónada o funciones puras (que no causan efectos al contexto de ejecución). Una vez realizada la composición de funciones, se llama a la función \mintinline{haskell}{atomically} para que las acciones realizadas dentro de la mónada STM sean realizadas atómicamente y sus efectos sean visibles al nível de la mónada IO.
Intuitivamente, uno puede interpretar a la composición de funciones STM como una transacción cuyos cambios realizados sólo pueden ser visibles una vez que se completa.
Dentro de una transacción, se debe utilizar un tipo de referencia distinto de \mintinline{haskell}{IORef}, ya que sus funciones no pueden ser realizadas dentro de la mónada STM. Para esto se tiene el tipo de variable transaccional \mintinline{haskell}{TVar} y funciones para escribir y leerlas.
A continuación se listan las funciones provistas por la librería STM en la Fig. \ref{fig:stm-interface}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
atomically :: STM a -> IO a
newTVar :: TVar a
readTVar :: a -> STM (TVar a)
writeTVar :: TVar a -> STM a -> a -> STM ()
\end{minted}
\caption{Funciones de la librería STM}
\label{fig:stm-interface}
\end{figure}

La librería STM también provee las funciones \mintinline{haskell}{retry} y \mintinline{haskell}{orElse} que permiten manipular el flujo de una transacción para que se realice un reintento o ejecutar una transacción en vez de otra en caso de que no sea exitosa.
Sin embargo, no fueron necesarias para las implementaciones que se realizaron en este trabajo y se encuentran detalladas en el próximo capítulo.

Dadas estas herramientas, se puede realizar una nueva implementación de la función \mintinline{haskell}{atomCAS} sobre STM.
El código de la función también fue presentado en \cite{linked-list}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
atomCASSTM :: Eq a => TVar a -> a -> a -> IO Bool
atomCASSTM ptr old new = atomically $ do
  cur <- readTVar ptr
  if cur == old
  then do
    writeTVar ptr new
    return True
  else return False
\end{minted}
\caption{\mintinline{haskell}{atomCAS} utilizando STM}
\end{figure}

Ahora se puede implementar una versión del contador sobre STM utilizando \mintinline{haskell}{TVar} como tipo de referencia y utilizando las funciones \mintinline{haskell}{atomCASSTM}, y \mintinline{haskell}{readTVar}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data Counter = TVar Int

inc :: Counter -> IO ()
inc counter = do
    loop <- newIORef True
    whileM_ (readIORef loop) $ do
        oldValue <- atomically $ readTVar counter
        let newValue = oldValue + 1
        success <- atomCASSTM counter oldValue newValue
        if success
            then writeIORef loop False
            else return ()
\end{minted}
\caption{Algoritmo optimista para incrementar un contador utilizando STM}
\label{fig:lockfree-counter-example-stm}
\end{figure}

Es importante notar que en el código de la Fig. \ref{fig:lockfree-counter-example-stm} la mónada continúa siendo IO ya que la llamada a la función \mintinline{haskell}{readTVar} está englobada por la función \mintinline{haskell}{atomically}. Este tipo de variaciones se verán reflejadas en varias de las funciones implementadas en el capítulo siguiente.

Además de poder implementar variantes de algoritmos optimistas, podemos implementar nuestro contador de una manera distinta y considerablemente más intuitiva utilizando las funciones STM como se muestra a continuación en la Fig. \ref{fig:counter-example-stm}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data Counter = TVar Int

inc :: Counter -> IO ()
inc counter = atomically $ do
    oldValue <- readTVar counter
    let newValue = oldValue + 1
    writeTVar counter newValue
\end{minted}
\caption{Algoritmo optimista para incrementar un contador}
\label{fig:counter-example-stm}
\end{figure}

Se puede apreciar cómo este estilo de algoritmos resultan más intuitivos que sus versiones optimistas gracias a que STM nos permite componer las funciones que necesitamos que sean ejecutadas atómicamente en vez de realizar llamadas a CAS y realizar reintentos en caso de que falle.
