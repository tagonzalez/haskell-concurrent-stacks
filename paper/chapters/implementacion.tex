\chapter{Implementación}\label{ch:implementation}
% Introducción del capítulo, hablar un poco lo que es una pila, las implementaciones de donde salen, la interfaz de las operaciones
Para este trabajo, se decidió realizar una experimentación sobre el tipo de datos conocido como pila. Una pila es representada por una referencia a un nodo que contiene un valor y una referencia al nodo que le sigue. Para el último nodo de la pila, la referencia al nodo siguiente será denominada como nula. En la figura \ref{fig:node-rep} se presenta la representación de un nodo en sus variantes de implementación IO y STM.

\begin{figure}[H]
  \centering
  \begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data Node a = Nd { val :: a, next :: IORef (Node a) } | Null
data Node a = Nd { val :: a, next :: TVar (Node a) } | Null
  \end{minted}
  \caption{Representación de un nodo en Haskell sobre IO y sobre STM}
  \label{fig:node-rep}
\end{figure}

En este capítulo se encuentra el detalle de las distintas implementaciones utilizadas para la evaluación de performance: \mintinline{haskell}{LockFreeStack} (sección \ref{sec:lfs}), \mintinline{haskell}{EliminationBackoffStack} (sección \ref{sec:ebs}), y \mintinline{haskell}{StackSTM}. Las primeras dos estructuras son maneras conocidas para la implementación de una pila concurrente y se encuentran detalladas en \hl{ref a shavit}. La estructura restante es una implementación \emph{naive} de una pila concurrente utilizando las herramientas provistas la librería STM de Haskell.

% Todas estas implementaciones cumplen con la misma interfaz típica del tipo de datos pila (stack).
% \begin{itemize}
% \item{\mintinline{haskell}{push} (apilar): apila un elemento al tope de la pila.}
% \item{\mintinline{haskell}{pop} (desapilar): devuelve el elemento en el tope de la pila y lo remueve. Si la pila se encuentra vacía (no hay elemento para desapilar, se arroja una excepción.}
% \end{itemize}


\begin{figure}[H]
  \centering
  \begin{minted}[breaklines,fontsize=\footnotesize]{haskell}
  push :: Eq a => Stack a -> a -> IO ()
  pop :: Eq a => Stack a -> IO a
  \end{minted}
  \caption{Interfaz para las funciones \mintinline{haskell}{push} y \mintinline{haskell}{pop}}
  \label{stackInterface}
\end{figure}

En el código utilizado para la experimentación cada versión de \mintinline{haskell}{push} y \mintinline{haskell}{pop} tendrán su nombre extendido por un texto para denotar a qué implementación pertenece. Por ejemplo, las funciones de un \mintinline{haskell}{LockFreeStack} tienen los nombres \mintinline{haskell}{pushLFS} y \mintinline{haskell}{popLFS}.

\section{LockFreeStack}\label{sec:lfs}
La estructura de datos \mintinline{haskell}{LockFreeStack} (LFS), también conocida como TreiberStack, consiste de una pila concurrente libre de locks que hace uso de la primitiva de sincronización de compare and set (CAS).

\begin{figure}[H]
  \centering
  \begin{minted}[breaklines,fontsize=\footnotesize]{haskell}
  data LockFreeStack a = LFS { top :: IORef (Node a), backoffLFS :: Backoff }
  data LockFreeStack a = LFS { top :: TVar (Node a), backoffLFS :: Backoff }
  \end{minted}
  \caption{Representación de un LFS}
  \label{repLFS}
\end{figure}

La idea detrás de los algoritmos es que cada hilo de ejecución intenté realizar una operación de escritura o lectura sobre la pila. Si el hilo no es exitoso en el intento, debe volver a intentar luego de esperar una cantidad de tiempo determinada por una estructura de backoff. Este comportamiento se puede apreciar en la figura~\ref{fig:lfs-push-pop} donde se muestra el código de las funciones \mintinline{haskell}{pushLFS} y \mintinline{haskell}{popLFS}. En ellas, se encuentran las llamadas a las funciones \mintinline{haskell}{tryPush} y \mintinline{haskell}{tryPop} respectivamente que serán detalladas en la subsección~\ref{sub:lfs-tries}, así también la llamada a la función \mintinline{haskell}{backoff} que se detalla en la subsección~\ref{sub:backoff}.

\begin{figure}[H]
  \centering
  \begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
pushLFS :: Eq a => LockFreeStack a -> a -> IO ()
pushLFS lfs value = do
  ret <- newIORef True
  node <- newNode value
  whileM_ (readIORef ret) $ do
    b <- tryPush lfs node
    if b
      then writeIORef ret False
      else backoff $ backoffLFS lfs

popLFS :: Eq a => LockFreeStack a -> IO a
popLFS lfs = do
  ret <- newIORef True
  res <- newIORef Nothing
  whileM_ (readIORef ret) $ do
    returnNode <- tryPop lfs
    if returnNode /= Null
      then do
        writeIORef res $ Just (val returnNode)
        writeIORef ret False
      else backoff (backoffLFS lfs)
  readIORef res >>= return.fromJust
  \end{minted}
  \caption{Implementación de las funciones \mintinline{haskell}{pushLFS} y \mintinline{haskell}{popLFS}}
  \label{fig:lfs-push-pop}
\end{figure}

Como se muestra en Fig.~\ref{fig:lfs-push-pop}, en ambas funciones se utiliza una variable \mintinline{haskell}{ret}, declarada en las líneas 3 y 14 para cada función, para determinar cuando se debe salir del ciclo en el que un hilo intenta realizar la operación y realiza un backoff en caso de fracaso. El código de estas funciones es idéntico en ambas variantes de implementación (IO y STM).

\subsection{Variantes de implementación: IO y STM}\label{sub:lfs-variants}
La estructura de datos LockFreeStack fue implementada en dos variantes. Dado que el método de sincronización de la estructura consiste en realizar una llamada a CAS, podemos considerar una implementación de CAS usando IORef y otra utilizando las primitivas de STM como se describe en \hl{ref a preliminares cas io y stm}.

El código que se muestra en Fig.~\ref{fig:lfs-push-pop} es idéntico para ambas variantes de implementación. La diferencia se podrá apreciar mejor en la subsección~\ref{sub:lfs-variants}.

\clearpage
\subsection{Backoff}\label{sub:backoff}
En la implementación utilizada, la estructura de backoff utilizada es del tipo de backoff exponencial. Al realizar la operación de backoff, la estructura toma un número aleatorio sobre un rango entre 0 y el límite establecido por parámetro y paraliza la ejecución del thread por esa cantidad de milisegundos. Luego la estructura duplica el valor del límite para la próxima vez que se realice la operación. Esta estructura se encuentra presentada en \hl{referencia a Shavit}

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data Backoff = BCK {minDelay :: Int, maxDelay :: Int, limit :: IORef Int}
newBackoff :: Int -> Int -> IO Backoff
newBackoff min max = (newIORef min) >>= return.(BCK min max)

backoff :: Backoff -> IO ()
backoff b = do
  backoffLimit <- readIORef $ limit b
  delayInMilliseconds <- randomRIO (0, backoffLimit)
  writeIORef (limit b) (min (maxDelay b) (2 * backoffLimit))
  threadDelay (toMicroseconds delayInMilliseconds)
    where toMicroseconds = (*) 1000
\end{minted}
\caption{Estructura de backoff}
\label{fig:backoff-code}
\end{figure}

La especificación de la función \mintinline{haskell}{backoff} según \hl{referencia a shavit} dicta que el hilo de ejecución debe pausar por una cantidad de milisegundos, por lo cual se vé necesario en la última linea de la figura~\ref{fig:backoff-code} convertir esa cantidad a microsegundos dado que la función \mintinline{haskell}{threadDelay} provista por la librería \mintinline{haskell}{base} \hl{referencia a base} de haskell toma microsegundos como parámetro.

\clearpage
\subsection{Intento de escritura o lectura}\label{sub:lfs-tries}
El comportamiento detrás del intento de escritura o lectura se define en las funciones tryPush y tryPop respectivamente. Ambas siguen la misma idea, observar el valor del tope de la pila y luego ejecutar CAS comparando lo que observa actualmente con lo observado en primer lugar. Si la comparación es exitosa, realizar la operación correspondiente (insertar un nuevo tope o remover el actual). Si no, realizar el backoff.

En el caso particular en la que un hilo desee remover un objeto en la pila, se debe realizar una verificación que la pila no se encuentre vacía. Si no hay ningún objeto para remover, se produce una excepción en la ejecución.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
tryPush :: Eq a => LockFreeStack a -> Node a -> IO Bool
tryPush lfs node = do
  oldTop <- readIORef (top lfs)
  writeIORef (next node) oldTop
  atomCAS (top lfs) oldTop node
\end{minted}
\caption{Implementación de \mintinline{haskell}{tryPush} (variante IO)}
\label{fig:lfs-trypush-io}
\end{figure}

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
tryPush :: Eq a => LockFreeStack a -> Node a -> IO Bool
tryPush lfs node = do
  oldTop <- atomically $ readTVar (top lfs)
  atomically $ writeTVar (next node) oldTop
  atomCAS (top lfs) oldTop node
\end{minted}
\caption{Implementación de \mintinline{haskell}{tryPush} (variante STM)}
\label{fig:lfs-trypush-stm}
\end{figure}

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
tryPop :: Eq a => LockFreeStack a -> IO (Node a)
tryPop lfs = do
  oldTop <- readIORef (top lfs)
  if oldTop == Null
    then
      throw EmptyException
    else do
      newTop <- readIORef (next oldTop)
      b <- atomCAS (top lfs) oldTop newTop
      if b
        then return oldTop
        else return Null
\end{minted}
\caption{Implementación de \mintinline{haskell}{tryPop} (variante IO)}
\end{figure}



\clearpage
\section{EliminationBackoffStack}\label{sec:ebs}

Un \mintinline{haskell}{EliminationBackoffStack} es una extensión para un LockFreeStack cuya idea principal es aprovechar el tiempo previo a un reintento para intentar realizar un intercambio con otro hilo que esté también esperando, pero para realizar la operación opuesta. Es decir, un hilo lector intentará hacer un intercambio con un hilo escritor y vice versa.

Para lograr este objetivo, se necesita de dos estructuras de datos alternativas: un \mintinline{haskell}{LockFreeExchanger}, un \mintinline{haskell}{EliminationArray}, y un \mintinline{haskell}{RangePolicy}.

% Agregar algo de historia sobre cómo surgió la implementación con referencias al Shavit

\subsection{LockFreeExchanger}\label{sub-lfe}
La estructura de datos \mintinline{haskell}{LockFreeExchanger} (LFE) consiste de una referencia que guarda información de estado y un valor asociado. El estado puede tomar 3 posibles valores:

\begin{itemize}
\item{\mintinline{haskell}{EMPTY}: no hay ningún valor asociado a la referencia}
\item{\mintinline{haskell}{WAITING}: un hilo ha escrito un valor en la referencia y está esperando a que un hilo lo lea}
\item{\mintinline{haskell}{BUSY}: un hilo a leído el valor que se encuentra en la referencia y escribe un valor para intercambiar}
\end{itemize}

La única función que realiza esta estructura de datos es la operación \mintinline{haskell}{exchange}. El método consiste en leer el estado del LFE y realizar la operación correspondiente al estado. La operación debe ocurrir dentro de una ventana de tiempo que es establecida mediante un parámetro \mintinline{haskell}{timeout} al ejecutar la función.

\begin{itemize}
\item{\mintinline{haskell}{EMPTY}: el hilo actual escribe el valor y el estado pasa a WATING. Luego espera a que el estado pase a BUSY, lo cual señala que otro hilo ha leído el valor y ha escrito su propio valor para el intercambio. Si el estado pasa a BUSY antes de que se cumpla el timeout, el hilo actual lee el valor escrito por el otro y termina la ejecución de la función.}
\item{\mintinline{haskell}{WAITING}: el hilo actual lee el valor escrito y escribe el suyo, luego termina la ejecución de la función.}
\item{\mintinline{haskell}{BUSY}: en este caso, ya hay dos hilos realizando un intercambio. Por lo tanto, el hilo actual debe reintentar de realizar un intercambio.}
\end{itemize}

Este comportamiento se puede apreciar en la figura~\ref{fig:exchange-io}

\begin{figure}[H]
  \centering
  \begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
exchange :: (Eq a) => LockFreeExchanger a -> Maybe a -> Integer -> IO (Maybe a)
exchange lfe myItem timeout = do
  ret <- newIORef True
  res <- newIORef Nothing
  let nanos = timeout * (10 ^ 6) -- timeout unit is millisecs
  timeBound <- systemNanoTime >>= return.((+) nanos)
  stampHolder <- newIORef EMPTY
  whileM_ (readIORef ret) $ do
    timeoutDone <- systemNanoTime >>= return.((<) timeBound)
    if timeoutDone
      then do
        throw TimeoutException
      else do
        yrItem <- getSlot (slot lfe) stampHolder
        stamp <- readIORef stampHolder
        case stamp of
          EMPTY -> do
            b <- atomCAS (slot lfe) (yrItem, EMPTY) (myItem, WAITING)
            if b
              then do
                whileM_ (emptyCaseLoopCondition ret timeBound) $ do
                  yrItem <- getSlot (slot lfe) stampHolder
                  stampBusy <- (readIORef stampHolder) >>= return.((==) BUSY)
                  if stampBusy
                    then do
                      writeIORef (slot lfe) (Nothing, EMPTY)
                      writeIORef ret False
                      writeIORef res yrItem
                    else
                      return ()
                breakFromWhile <- readIORef ret >>= return.not
                if breakFromWhile
                  then return ()
                  else do
                    b <- atomCAS (slot lfe) (myItem, WAITING) (Nothing, EMPTY)
                    if b
                      then do
                        throw TimeoutException
                      else do
                        yrItem <- getSlot (slot lfe) stampHolder
                        writeIORef (slot lfe) (Nothing, EMPTY)
                        writeIORef res yrItem
              else do
                return ()
          WAITING -> do
            b <- atomCAS (slot lfe) (yrItem, WAITING) (myItem, BUSY)
            if b
              then do
                writeIORef ret False
                writeIORef res yrItem
              else
                return ()
          BUSY -> do
            return ()
  readIORef res

  where emptyCaseLoopCondition ret timeBound = do
          timeoutNotDone <- systemNanoTime >>= return.((>) timeBound)
          (readIORef ret) >>= return.((&&) timeoutNotDone)

        systemNanoTime = (getTime Realtime) >>= return.toNanoSecs
\end{minted}
  \caption{Implementación de la función \mintinline{haskell}{exchange}}
  \label{fig:exchange-io}
\end{figure}

\subsection{EliminationArray}
Un \mintinline{haskell}{EliminationArray} es una simple estructura de datos que mantiene un arreglo de instancias de \mintinline{haskell}{LockFreeExchanger} y la información pertinente a la duración del \mintinline{haskell}{timeout} que deberá cumplir cada una de las llamadas a \mintinline{haskell}{exchange} que se realicen.
La estructura tiene sólo una función \mintinline{haskell}{visit} que elige aleatoriamente cual de los exchangers de su arreglo utilizar para realizar el intercambio. Luego ejecuta la función \mintinline{haskell}{visit} para el exchanger elegido.

\subsection{Estrategia de backoff del EliminationBackoffStack}
La estructura \mintinline{haskell}{EliminationBackoffStack} (EBS) tiene un comportamiento muy similar a un \mintinline{haskell}{LockFreeStack}. La diferencia se encuentra en las acciones que cada estructura realiza cuando la operación inicial falla, y por lo tanto debe esperar antes de reintentar. En el caso del LFS, el hilo debe esperar un tiempo sin realizar ninguna acción y reintenta, mientras que en un EBS este intenta aprovechar el tiempo de espera para realizar un intercambio con otro hilo que haya fallado su intento.

Para poder optimizar las probabilidades de lograr un intercambio en ese tiempo de espera. Un EBS cuenta con otra estructura adicional conocida como \mintinline{haskell}{RangePolicy}. Esta estructura tiene como función manejar el rango del \mintinline{haskell}{EliminationArray} en el cual se eligirá el exchanger a utilizar.
La idea general del funcionamiento es que con cada intento de intercambio el rango puede ampliarse si el intercambio es exitoso, y reducirse en el caso de que el intercambio fracase.
Al reducir el rango aumenta la probabilidad de que dos hilos elijan la misma posición del arreglo para realizar el intercambio, y al incrementar el rango se puede permitir que más intercambios sucedan al mismo tiempo si es que hay suficientes hilos como para cubrir las posiciones del arreglo.

Luego, en las funciones \mintinline{haskell}{pushEBS} y \mintinline{haskell}{popEBS}, se intenta realizar la operación con las mismas funciones que utiliza un LFE, \mintinline{haskell}{tryPush} y \mintinline{haskell}{tryPop} respectivamente, y en el caso de que haya una falla, se obtiene el rango dictado por el \mintinline{haskell}{RangePolicy} y se llama a la función \mintinline{haskell}{visit} del EBS con el rango pasado como argumento.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
pushEBS :: Eq a => EliminationBackoffStack a -> a -> IO ()
pushEBS ebs value = do
  ret <- newIORef True
  rangePolicy <- getTLS (policy ebs)

  range <- getRange rangePolicy
  node <- newNode value
  whileM_ (readIORef ret) $ do
    b <- tryPush ebs node
    if b
      then writeIORef ret False
      else (catch (tryExchangePush ebs node value range ret rangePolicy) $ \( e :: TimeoutException) -> do
          recordEliminationTimeout rangePolicy)

  where tryExchangePush ebs node value range ret rangePolicy = do
          otherValue <- visit (eliminationArray ebs) (Just value) range
          if otherValue == Nothing
            then do
              recordEliminationSuccess rangePolicy
              writeIORef ret False
            else return ()
\end{minted}
\caption{Ejemplo de \mintinline{haskell}{pushEBS}}
\end{figure}

\clearpage
\subsection{Variantes de implementación: IO y STM}
Al igual que sucede con la estructura \mintinline{haskell}{LockFreeStack}, hay dos variantes implementadas para \mintinline{haskell}{EliminationBackoffStack}, una utilizando la primitiva de sincronización \mintinline{haskell}{atomCAS} implementada sobre \mintinline{haskell}{IO} y la otra utilizando \mintinline{haskell}{STM} para la implementación.
Dado que la llamada a \mintinline{haskell}{atomCAS} ocurre en la función \mintinline{haskell}{exchange} del módulo de \mintinline{haskell}{LockFreeExchanger}, las tres estructuras tienen estas dos sus variantes de implementación: \mintinline{haskell}{EliminationBackoffStack}, \mintinline{haskell}{EliminationArray}, y \mintinline{haskell}{LockFreeExchanger}.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
-- Implementación IO
data EliminationBackoffStack a = EBS { top :: IORef (Node a), capacity :: Int, eliminationArray :: EliminationArray a, policy :: TLS RangePolicy}

data EliminationArray a = EA {exchanger :: [LockFreeExchanger a], duration :: Integer}

data LockFreeExchanger a = LFE {slot :: IORef (Maybe a, State)}

--Implementación STM
data EliminationBackoffStack a =EBS {top :: TVar (Node a), capacity :: Int, eliminationArray :: EliminationArray a, policy :: TLS RangePolicy}

data EliminationArray a = EA {exchanger :: [LockFreeExchanger a], duration :: Integer}

data LockFreeExchanger a = LFE {slot :: TVar (Maybe a, State)}
\end{minted}
\caption{Variantes de implementación para las estructuras del EBS}
\end{figure}

\clearpage
\section{StackSTM}
La última estructura de datos implementada es \mintinline{haskell}{StackSTM}. La implementación para esta estructura intenta aprovechar lo más posible las herramientas que provee la librería \mintinline{haskell}{STM} de Haskell.

\begin{figure}[H]
\begin{minted}[linenos,breaklines,fontsize=\footnotesize]{haskell}
data StackSTM a = ST {top :: TVar (Node a)}

newStackSTM :: IO (StackSTM a)
newStackSTM = atomically (newTVar Null) >>= return.ST

pushStackSTM:: StackSTM a -> a -> IO ()
pushStackSTM st value = do
  node <- newNode value
  atomically $ do
    oldTop <- readTVar $ top st
    writeTVar (next node) oldTop
    writeTVar (top st) node

popStackSTM:: Show a => StackSTM a -> IO a
popStackSTM st = atomically $ do
    resNode <- readTVar $ top st
    case resNode of
      Nd v nxt -> do
        newTop <- readTVar nxt
        writeTVar (top st) newTop
        return v
      Null -> throw EmptyException   
\end{minted}
\caption{Implementación completa de \mintinline{haskell}{StackSTM}}
\end{figure}